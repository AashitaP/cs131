1. For subset, my initial idea was to check every element of a against every element of b but since I could not do so without using loops, I modified it into checking if every element of a is in b (using a helper function) and use this helper function recursively. Once I figured out the first function, the rest were more straightforward - The remaining functions (set_union, set_intersection & set_diff) used the same pattern matching approach and an empty list as the base case. 

2. I implemented computed_fixed_point following the definition which was inherently recursive. Since the spec allowed going into a loop, I left the implementation to do that in the case where it could not find a solution. 

3. For filter_reachable I first approached it using brute force. The idea was that for each row in the list of rules, if the start symbol was in the left hand side, the start symbol had to be set to each of the non terminal symbols on the right hand side list. However, I could not think of an approach that would allow me to set the start symbol to each symbol in the list, check all the reachable rules and then go back to the start symbol. Hence, instead of setting the start symbol to the right hand list, I checked if the left hand side existed in any of the created set of reachable rules where the first rule would be the rule where the left hand side matches the start symbol. 

Following this, I first worked on checking if it contains by breaking down the list of rules - into each row, and then its left hand side and right hand side list, and then into each element in the list and finally checking for a match - using helper functions.
For the next part, a helper function was called recursively every time the return list expanded and stopped being called when the return list no longer changed. For this I initially called the function everytime I compared the two sets and realized that this was similar to what computed_fixed_point and equal_sets did. 